#!/usr/bin/env python3 -u
#
# This file is part of teld.
#
# teld is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# teld is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with teld.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=no-self-use

import json
import math
import os
import subprocess
import threading
import time
import Pyro4

PYRO_HOST = 'localhost'
PYRO_PORT = 9003

TELSTAT_PATH = '/usr/local/telescope/bin/telstat'
FIFO_PATH = '/usr/local/telescope/comm/'
FIFO_NAMES = ['Tel.in', 'Cover.in', 'Focus.in']

# Delay between telstat queries (in seconds)
TELSTAT_QUERY_DELAY = 1

# Covers should update immediately, so delay mainly covers fifo / telstat delays
COVER_TIMEOUT = 2.5

# This can take quite a while
# TODO: Measure this time
HOMING_TIMEOUT = 120
LIMIT_TIMEOUT = 120
SLEW_TIMEOUT = 120

SLEW_TO_ZENITH = 'Alt: 1.570796 Az: 0'

# This should be kept in sync with the dictionary in tel
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

    # Command-specific codes
    TelescopeNotInitialized = 10
    TelescopeNotReady = 11

class TelescopeStatus:
    """Status of the telescope hardware"""
    Disabled, NotHomed, Ready, Tracking = range(4)

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class TelescopeDaemon:
    """Daemon interface for talon subystems"""
    def __init__(self):
        # Motor offsets for jogging and autoguiding
        # Measured in radians
        self._offset_ra = 0
        self._offset_dec = 0

        # Only one command may be active at a time (except for stop)
        self._command_lock = threading.Lock()
        self._pointing_condition = threading.Condition()
        self._cover_condition = threading.Condition()

        self._status = TelescopeStatus.Disabled

        # Status data from telstat
        self._status_data = None
        self._status_data_lock = threading.Lock()

        self._last_pointing_state = 'TS_STOPPED'
        self._pointing_state = 'TS_STOPPED'
        self._pointing_force_stopped = False

        self._last_cover_state = 'CV_ABSENT'
        self._cover_state = 'CV_ABSENT'

        tel_status_thread = threading.Thread(target=self.poll_tel_status)
        tel_status_thread.daemon = True
        tel_status_thread.start()

    def poll_tel_status(self):
        """Background thread that polls telstat for the current telescope status"""
        while True:
            # Acquire all condition locks to avoid races with commands
            with self._cover_condition:
                with self._pointing_condition:
                    new_status = None
                    try:
                        output = subprocess.check_output(
                            TELSTAT_PATH, universal_newlines=True, timeout=5)
                        new_status = json.loads(output)
                    except:
                        print("Failed to query telstat")

                    if new_status is not None:
                        with self._status_data_lock:
                            self._status_data = new_status

                            self._last_pointing_state = self._pointing_state
                            self._pointing_state = self._status_data['tel_state']

                            self._last_cover_state = self._cover_state
                            self._cover_state = self._status_data['cover_state']

                        if self._last_pointing_state != self._pointing_state:
                            print(self._last_pointing_state + ' -> ' + self._pointing_state)
                            self._pointing_condition.notify()

                        if self._last_cover_state != self._cover_state:
                            print(self._last_cover_state + ' -> ' + self._cover_state)
                            self._cover_condition.notify()

                    # Check that talon is still running
                    talon_alive = True
                    for fifo_name in FIFO_NAMES:
                        if not os.path.exists(FIFO_PATH + fifo_name):
                            talon_alive = False
                            break

                    if not talon_alive:
                        if self._status != TelescopeStatus.Disabled:
                            print('Talon has gone away...')
                            # Talon has just died on us!
                            # Wake up any active commands so that they can fail
                            self._pointing_condition.notify()
                            self._cover_condition.notify()

                            print('Status: {} -> {}'.format(self._status,
                                                            TelescopeStatus.Disabled))
                        self._status = TelescopeStatus.Disabled
                    elif self._status == TelescopeStatus.Disabled:
                        # Talon has been restarted
                        axes = self._status_data['axes']
                        # TODO: focus homing
                        if bool(axes[0]['ishomed']) and bool(axes[1]['ishomed']):
                            print('Status: {} -> {}'.format(self._status, TelescopeStatus.Ready))
                            self._status = TelescopeStatus.Ready
                        else:
                            print('Status: {} -> {}'.format(self._status, TelescopeStatus.NotHomed))
                            self._status = TelescopeStatus.NotHomed

            time.sleep(TELSTAT_QUERY_DELAY)

    def reset_pointing_offset(self):
        """Resets the pointing xdelta"""
        if not fifo_write('Tel.in', 'xdelta(0,0)'):
            print('Failed to write to Tel.in')
            return False

        self._offset_ra = 0
        self._offset_dec = 0
        return True

    def point(self, fifo_command, active_state, final_state, timeout):
        """Issues a pointing command and blocks until the final state is reached (or timeout)"""
        with self._pointing_condition:
            if not fifo_write('Tel.in', fifo_command):
                print('Failed to write to Tel.in')
                return False

            stopped = False
            while True:
                self._pointing_condition.wait(timeout)
                stopped = self._pointing_force_stopped or self._status == TelescopeStatus.Disabled

                # Ignore the initial state change to <active_state>, which we may
                # or may not recieve depending on the timing of the telstat loop
                if self._pointing_state == active_state and not stopped:
                    continue
                break

            if self._pointing_state != final_state or stopped:
                return False

        return True

    def slew_to_radec(self, ra_radians, dec_radians):
        """Quickly slew to a specified RA and Dec"""
        # Uses the "HA: Dec:" command to slew
        with self._status_data_lock:
            lst_radians = self._status_data['lst'] * math.pi / 12

        ha_radians = lst_radians - ra_radians
        command = 'HA: {} Dec: {}'.format(ha_radians, dec_radians)
        return self.point(command, 'TS_SLEWING', 'TS_STOPPED', SLEW_TIMEOUT)

    def move_covers(self, fifo_command, active_state, final_state, timeout):
        """Issues a cover command and blocks until the final state is reached (or timeout)"""
        with self._cover_condition:
            if not fifo_write('Cover.in', fifo_command):
                print('Failed to write to Cover.in')
                return False

            stopped = False
            while True:
                self._cover_condition.wait(timeout)
                stopped = self._status == TelescopeStatus.Disabled

                # Ignore the initial state to <active_state>, which we may or
                # may not recieve depending on the timing of the telstat loop
                if self._cover_state == active_state and not stopped:
                    continue
                break

            if self._cover_state != final_state or stopped:
                return False
        return True

    @Pyro4.expose
    def initialize(self):
        """Turns on the power and starts the lower level hardware daemons"""
        # TODO: Implement this properly
        subprocess.call('/usr/local/bin/pdu_power_on')
        subprocess.call('/usr/local/bin/pdu_telescope_80v_power_on')

        # systemd starts teld with a clean environment
        # load the talon-specific environment just for talon
        talon_env = environment_from_source('/etc/profile.d/talon.sh')
        with open(os.devnull, 'w') as devnull:
            subprocess.call(['/usr/local/telescope/bin/rund', 'telescoped'], env=talon_env, stdout=devnull, stderr=devnull)

        return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disables and powers off the telescope"""
        # TODO: Implement this properly
        subprocess.call(['/usr/local/telescope/bin/killTel', '-all'])
        subprocess.call('/usr/local/bin/pdu_power_off')
        return CommandStatus.Succeeded

    @Pyro4.expose
    def find_homes(self):
        """Finds the axis home positions"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            print('Homing HA axis...')
            if not self.point('homeH', 'TS_HOMING', 'TS_STOPPED', HOMING_TIMEOUT):
                return CommandStatus.Failed

            print('Homing Dec axis...')
            if not self.point('homeD', 'TS_HOMING', 'TS_STOPPED', HOMING_TIMEOUT):
                return CommandStatus.Failed

            # TODO: Focus home

            self._status = TelescopeStatus.Ready
            return CommandStatus.Succeeded

    @Pyro4.expose
    def find_limits(self):
        """Performs the home and limit calibrations"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if not self.point(SLEW_TO_ZENITH, 'TS_SLEWING', 'TS_STOPPED', SLEW_TIMEOUT):
                return CommandStatus.Failed

            print('Finding HA limits...')
            if not self.point('limitsH', 'TS_LIMITING', 'TS_STOPPED', LIMIT_TIMEOUT):
                return CommandStatus.Failed

            if not self.point(SLEW_TO_ZENITH, 'TS_SLEWING', 'TS_STOPPED', SLEW_TIMEOUT):
                return CommandStatus.Failed

            print('Finding Dec limits...')
            if not self.point('limitsD', 'TS_LIMITING', 'TS_STOPPED', LIMIT_TIMEOUT):
                return CommandStatus.Failed

            if not self.point(SLEW_TO_ZENITH, 'TS_SLEWING', 'TS_STOPPED', SLEW_TIMEOUT):
                return CommandStatus.Failed

            # TODO: Focus limits
            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active telescope movement"""
        if self._status == TelescopeStatus.Disabled:
            return CommandStatus.TelescopeNotInitialized

        # The stop command overrides all other pointing commands
        self._pointing_force_stopped = True

        if not fifo_write('Tel.in', 'Stop'):
            print('Failed to write to Tel.in')
            return CommandStatus.Failed

        with self._pointing_condition:
            self._pointing_condition.notify_all()

        # Block until any other pointing commands have terminated before cleaning up
        with self._command_lock:
            self._pointing_force_stopped = False

        return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_altaz(self, alt_radians, az_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            command = 'Alt: {} Az: {}'.format(alt_radians, az_radians)
            if not self.point(command, 'TS_SLEWING', 'TS_STOPPED', SLEW_TIMEOUT):
                return CommandStatus.Failed

            if not self.reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_radec(self, ra_radians, dec_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            # TODO: Work out if the requested coords are outside
            # limits and return an error immediately
            if not self.slew_to_radec(ra_radians, dec_radians):
                return CommandStatus.Failed

            if not self.reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def track_radec(self, ra_radians, dec_radians):
        """Moves the telescope to a target and starts tracking"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            # Slewing is much faster than tracking
            if not self.slew_to_radec(ra_radians, dec_radians):
                return CommandStatus.Failed

            # Do the final adjustment and start tracking
            command = 'RA: {} Dec: {}'.format(ra_radians, dec_radians)
            if not self.point(command, 'TS_HUNTING', 'TS_TRACKING', SLEW_TIMEOUT):
                return CommandStatus.Failed

            if not self.reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def offset_radec(self, ra_delta_radians, dec_delta_radians):
        """Offsets the telescope relative to the current position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._pointing_state == 'TS_TRACKING':
                # When tracking we must use the xdelta offset to directly
                # offset at the motor controller
                self._offset_ra += ra_delta_radians
                self._offset_dec += dec_delta_radians

                fifo_command = 'xdelta({},{})'.format(self._offset_ra, self._offset_dec)
                if not fifo_write('Tel.in', fifo_command):
                    print('Failed to write to Tel.in')
                    return False
            else:
                # Otherwise just slew to the updated position
                with self._status_data_lock:
                    ra_radians = float(self._status_data['ra'])
                    dec_radians = float(self._status_data['dec'])

                ra_radians += ra_delta_radians
                dec_radians += dec_delta_radians

                if not self.slew_to_radec(ra_radians, dec_radians):
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def open_covers(self):
        """Open the mirror covers"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            print('Opening covers...')
            if not self.move_covers('coveropen', 'CV_OPENING', 'CV_OPEN', COVER_TIMEOUT):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def close_covers(self):
        """Close the mirror covers"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            print('Opening covers...')
            if not self.move_covers('coverclose', 'CV_CLOSING', 'CV_CLOSED', COVER_TIMEOUT):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def primary_focus(self, microns):
        """Sets the primary focus to the specified position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            # TODO: Implement primary focus command
            return CommandStatus.Failed

    @Pyro4.expose
    def secondary_focus(self, steps):
        """Sets the secondary focus to the specified position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            # TODO: Implement secondary focus command
            return CommandStatus.Failed

def environment_from_source(source_path):
    try:
        command = ['bash', '-c', 'source ' + source_path + ' && env']
        output = subprocess.check_output(command, universal_newlines=True, timeout=5)
        ret = dict()
        for line in output.split('\n'):
            (key, _, value) = line.partition('=')
            ret[key] = value
        return ret
    except:
        return dict()

def fifo_write(fifo_name, fifo_data):
    """Writes a string into the named fifo"""
    try:
        # Don't create a new file if the fifo doesn't exist
        fd = os.open(FIFO_PATH+fifo_name, os.O_WRONLY)
    except OSError:
        return False

    with os.fdopen(fd, 'w') as fifo:
        print('Writing to ' + fifo_name+ ': ' + fifo_data)
        fifo.write(fifo_data+'\n')
        return True

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = 5
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=PYRO_HOST, port=PYRO_PORT)
    telescope = TelescopeDaemon()
    uri = pyro.register(telescope, objectId='telescope_daemon')

    print('Starting telescope daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping telescope daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()
