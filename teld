#!/usr/bin/env python3.6
#
# This file is part of teld.
#
# teld is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# teld is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with teld.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling a telescope through Talon/telescoped/csimcd via Pyro"""

import argparse
import glob
import math
import os
import signal
import subprocess
import threading
import time
import sysv_ipc
from astropy.coordinates import SkyCoord, EarthLocation, get_moon, get_sun
from astropy.time import Time
import astropy.units as u
import Pyro4

from warwick.observatory.common import log, TryLock
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.observatory.talon import (
    CommandStatus, TelState, FocusState, CoverState, RoofState, Config,
    ShmOffsets, shm_read_double, shm_read_int, shm_read_ushort)

# Set automatically when generating RPM package
SOFTWARE_VERSION = "UNKNOWN"

FIFO_PATH = '/usr/local/telescope/comm/'
FIFO_NAMES = ['Tel.in', 'Cover.in', 'Focus.in']


class TelescopeDaemon:
    """Daemon interface for talon subsystems"""
    def __init__(self, config):
        self._config = config

        # Motor offsets for jogging and autoguiding
        self._offset_ra = 0 * u.deg
        self._offset_dec = 0 * u.deg

        # Only one command may be active at a time (except for stop)
        self._command_lock = threading.Lock()
        self._pointing_condition = threading.Condition()
        self._cover_condition = threading.Condition()
        self._roof_condition = threading.Condition()
        self._telescope_focus_condition = threading.Condition()
        self._force_stopped = False

        # Status data from shared memory
        self._talon_shm = None
        self._talon_shm_lock = threading.Lock()

        self._observatory = None
        self._current_ra_j2000 = 0 * u.rad
        self._current_dec_j2000 = 0 * u.rad
        self._current_ha_apparent = 0 * u.rad
        self._current_dec_apparent = 0 * u.rad
        self._current_alt = 0 * u.rad
        self._current_az = 0 * u.rad
        self._current_lst = 0 * u.rad

        self._last_pointing_state = TelState.Absent
        self._pointing_state = TelState.Absent
        self._last_pointing_idx = 0
        self._pointing_idx = 0
        self._axes_homed = False

        self._last_cover_state = CoverState.Absent
        self._cover_state = CoverState.Absent

        self._last_roof_state = RoofState.Absent
        self._roof_state = RoofState.Absent

        self._last_telescope_focus_state = FocusState.Absent
        self._telescope_focus_state = FocusState.Absent
        self._telescope_focus_um = 0
        self._last_telescope_focus_um = 0

        self._ha_positive_limit = 0 * u.rad
        self._ha_negative_limit = 0 * u.rad
        self._dec_positive_limit = 0 * u.rad
        self._dec_negative_limit = 0 * u.rad

        self._last_talon_mjd = 0
        self._talon_mjd = 0
        self._talon_pid = 0

        tel_status_thread = threading.Thread(target=self.__poll_tel_status)
        tel_status_thread.daemon = True
        tel_status_thread.start()

    def __update_state_from_talon_shm(self):
        """Update local copies of state variables from talon shared memory segment"""
        try:
            if self._talon_shm is None:
                self._talon_shm = sysv_ipc.SharedMemory(ShmOffsets.Key)

            with self._talon_shm_lock:
                self._last_talon_mjd = self._talon_mjd
                self._talon_mjd = shm_read_double(self._talon_shm, ShmOffsets.MJD)

                # Talon stops updating the shared memory if the hardware crashes
                # We use this as a proxy for checking that the daemons are operating correctly
                talon_alive = 0 < self._talon_mjd != self._last_talon_mjd

                # The first stage of talon boot up zeros the shared memory.
                # Wait for it to be updated with sensible data
                if self._talon_mjd > 0:
                    self._last_pointing_state = self._pointing_state
                    self._last_pointing_idx = self._pointing_idx
                    pointing_state = shm_read_int(self._talon_shm, ShmOffsets.TelState)
                    if not talon_alive:
                        pointing_state = TelState.Absent

                    self._pointing_state = pointing_state
                    self._pointing_idx = shm_read_int(self._talon_shm, ShmOffsets.TelStateIdx)

                    self._last_cover_state = self._cover_state
                    self._cover_state = shm_read_int(self._talon_shm, ShmOffsets.CoverState)

                    self._last_roof_state = self._roof_state
                    self._roof_state = shm_read_int(self._talon_shm, ShmOffsets.RoofState)

                    self._current_ra_j2000 = shm_read_double(self._talon_shm, ShmOffsets.RAJ2000) * u.rad
                    self._current_dec_j2000 = shm_read_double(self._talon_shm, ShmOffsets.DecJ2000) * u.rad

                    self._current_ha_apparent = shm_read_double(self._talon_shm, ShmOffsets.HAApparent) * u.rad
                    self._current_dec_apparent = shm_read_double(self._talon_shm, ShmOffsets.DecApparent) * u.rad
                    self._current_lst = shm_read_double(self._talon_shm, ShmOffsets.LST) * u.rad

                    self._current_alt = shm_read_double(self._talon_shm, ShmOffsets.Alt) * u.rad
                    self._current_az = shm_read_double(self._talon_shm, ShmOffsets.Az) * u.rad

                    ra_flags = shm_read_ushort(self._talon_shm, ShmOffsets.RAFlags)
                    dec_flags = shm_read_ushort(self._talon_shm, ShmOffsets.DecFlags)
                    focus_flags = shm_read_ushort(self._talon_shm, ShmOffsets.FocusFlags)
                    focus_step = shm_read_int(self._talon_shm, ShmOffsets.FocusStep)
                    focus_pos = shm_read_double(self._talon_shm, ShmOffsets.FocusCPos)
                    focus_df = shm_read_double(self._talon_shm, ShmOffsets.FocusDF)

                    self._last_telescope_focus_state = self._telescope_focus_state
                    self._telescope_focus_state = FocusState.Absent
                    if focus_flags & 0x01 == 1:
                        self._telescope_focus_state = FocusState.NotHomed
                        if focus_flags & 0x80 != 0:
                            self._telescope_focus_state = FocusState.Homing
                        if focus_flags & 0x80 != 0:
                            self._telescope_focus_state = FocusState.Homing
                        elif focus_flags & 0x100 != 0:
                            self._telescope_focus_state = FocusState.Limiting
                        elif focus_flags & 0x200 != 0:
                            self._telescope_focus_state = FocusState.Ready

                    self._last_telescope_focus_um = self._telescope_focus_um
                    self._telescope_focus_um = focus_step * focus_pos / (2 * math.pi * focus_df)

                    self._axes_homed = ra_flags & 0x200 != 0 and dec_flags & 0x200 != 0 and \
                                       (focus_flags & 0x01 == 0 or focus_flags & 0x200 != 0)

        except sysv_ipc.ExistentialError:
            # Talon has not been initialized since last boot
            talon_alive = False
        except Exception as e:
            # Some other unexpected error occurred - log it
            log.error(self._config.log_name, 'Failed parsing shared memory: ' + str(e))
            talon_alive = False

        if not talon_alive and self._last_pointing_state != TelState.Absent:
            # Talon has just died on us!
            log.info(self._config.log_name, 'Talon is offline')

            # Kill telescoped and csimcd
            log.info(self._config.log_name, 'Killing rund-spawned daemons')
            subprocess.call(['/usr/bin/killall', 'rund'])

            # Clear interprocess-communication channels
            for f in glob.glob('/usr/local/telescope/comm/*'):
                print('Removing ' + f)
                try:
                    os.unlink(f)
                except Exception:
                    pass

            self._talon_pid = 0

            # Wake up any active commands so that they can fail
            self._pointing_condition.notify()
            self._cover_condition.notify()
        elif talon_alive and self._last_pointing_state == TelState.Absent:
            # Either we or talon has been restarted... find current status
            log.info(self._config.log_name, 'Talon is online')

            with self._talon_shm_lock:
                self._talon_pid = shm_read_int(self._talon_shm, ShmOffsets.PID)

                self._observatory = EarthLocation(
                    lat=shm_read_double(self._talon_shm, ShmOffsets.Latitude) * u.rad,
                    lon=shm_read_double(self._talon_shm, ShmOffsets.Longitude) * u.rad,
                    height=shm_read_double(self._talon_shm, ShmOffsets.Elevation) * 6.37816e6 * u.m)

                # Update limits
                self._ha_positive_limit = shm_read_double(self._talon_shm, ShmOffsets.RAPosLim) * u.rad
                self._ha_negative_limit = shm_read_double(self._talon_shm, ShmOffsets.RANegLim) * u.rad
                self._dec_positive_limit = shm_read_double(self._talon_shm, ShmOffsets.DecPosLim) * u.rad
                self._dec_negative_limit = shm_read_double(self._talon_shm, ShmOffsets.DecNegLim) * u.rad

    def __poll_tel_status(self):
        """Background thread that polls shared memory for the current telescope status"""
        while True:
            # Acquire all condition locks to avoid races with commands
            with self._pointing_condition:
                with self._cover_condition:
                    with self._roof_condition:
                        with self._telescope_focus_condition:
                            self.__update_state_from_talon_shm()

                            if self._last_pointing_idx != self._pointing_idx:
                                print('Pointing: {} ({}) -> {} ({})'.format(
                                    TelState.label(self._last_pointing_state), self._last_pointing_idx,
                                    TelState.label(self._pointing_state), self._pointing_idx))
                                self._pointing_condition.notify_all()

                            if self._last_cover_state != self._cover_state:
                                print('Cover: ' + CoverState.label(self._last_cover_state) + ' -> ' +
                                      CoverState.label(self._cover_state))
                                self._cover_condition.notify_all()

                            if self._last_roof_state != self._roof_state:
                                print('Roof: ' + RoofState.label(self._last_roof_state) + ' -> ' +
                                      RoofState.label(self._roof_state))
                                self._roof_condition.notify_all()

                            if self._last_telescope_focus_um != self._telescope_focus_um:
                                print('tel focus: {:2f} -> {:2f}'.format(
                                    self._last_telescope_focus_um, self._telescope_focus_um))
                                self._telescope_focus_condition.notify_all()

                            if self._telescope_focus_state != self._last_telescope_focus_state:
                                print('Focus: ' + FocusState.label(self._last_telescope_focus_state) +
                                      ' -> ' + FocusState.label(self._telescope_focus_state))
                                self._telescope_focus_condition.notify_all()

            time.sleep(self._config.query_delay)

    def __reset_pointing_offset(self):
        """Resets the pointing xdelta"""
        if not fifo_write('Tel.in', 'xdelta(0,0)'):
            log.error(self._config.log_name, 'Failed to write to Tel.in')
            return False

        self._offset_ra = 0 * u.deg
        self._offset_dec = 0 * u.deg
        return True

    def __point(self, fifo_command, active_state, final_state, timeout):
        """Issues a pointing command and blocks until the final state is reached (or timeout)"""
        with self._pointing_condition:
            if not fifo_write('Tel.in', fifo_command):
                log.error(self._config.log_name, 'Failed to write to Tel.in')
                return False

            while True:
                self._pointing_condition.wait(timeout)
                stopped = self._force_stopped or self._pointing_state == TelState.Absent

                # Ignore the initial state change to <active_state>, which we may
                # or may not receive depending on the timing of the telstat loop
                if self._pointing_state == active_state and not stopped:
                    continue
                break

            if self._pointing_state != final_state or stopped:
                return False

        return True

    def __focus(self, fifo_command, active_state, final_state, timeout):
        """Issues a focus command and blocks until the final state is reached (or timeout)"""
        if self._telescope_focus_state == FocusState.Absent:
            return False

        with self._telescope_focus_condition:
            if not fifo_write('Focus.in', fifo_command):
                log.error(self._config.log_name, 'Failed to write to Focus.in')
                return False

            while True:
                self._telescope_focus_condition.wait(timeout)
                stopped = self._force_stopped or self._pointing_state == TelState.Absent

                # Ignore the initial state change to <active_state>, which we may
                # or may not receive depending on the timing of the telstat loop
                if self._telescope_focus_state == active_state and not stopped:
                    continue
                break

            if self._telescope_focus_state != final_state or stopped:
                return False

        return True

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current telescope state"""
        data = {
            'state': self._pointing_state,
            'state_label': TelState.label(self._pointing_state),
            'software_version': SOFTWARE_VERSION
        }

        if self._observatory is not None:
            data.update({
                'site_latitude': self._observatory.lat.to_value(u.deg),
                'site_longitude': self._observatory.lon.to_value(u.deg),
                'site_elevation': self._observatory.height.to_value(u.m),
            })

        if self._pointing_state != TelState.Absent:
            data.update({
                'axes_homed': self._axes_homed,
                'cover_state': self._cover_state,
                'roof_state': self._roof_state,
                'roof_state_label': RoofState.label(self._roof_state),
                'telescope_focus_state': self._telescope_focus_state,
                'lst': self._current_lst.to_value(u.deg),
            })

            if self._axes_homed:
                timenow = Time(Time.now(), format='mjd', location=self._observatory)
                pointing = SkyCoord(self._current_ra_j2000, self._current_dec_j2000, frame='fk5')
                data.update({
                    'ra': self._current_ra_j2000.to_value(u.deg),
                    'dec': self._current_dec_j2000.to_value(u.deg),
                    'offset_ra': self._offset_ra.to_value(u.deg),
                    'offset_dec': self._offset_dec.to_value(u.deg),

                    'ha': self._current_ha_apparent.to_value(u.deg),

                    'alt': self._current_alt.to_value(u.deg),
                    'az': self._current_az.to_value(u.deg),

                    'telescope_focus_um': self._telescope_focus_um,

                    'moon_separation': get_moon(timenow).separation(pointing).to_value(u.deg),
                    'sun_separation': get_sun(timenow).separation(pointing).to_value(u.deg),
                })

        return data

    @Pyro4.expose
    def initialize(self):
        """Turns on the power and starts the lower level hardware daemons"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._pointing_state != TelState.Absent:
                return CommandStatus.TelescopeNotUninitialized

            # Check hard limits (security system)
            if self._config.security_system_daemon:
                try:
                    with self._config.security_system_daemon.connect() as daemon:
                        status = daemon.last_measurement()
                        key = self._config.security_system_key
                        if key not in status or not status[key]:
                            return CommandStatus.SecuritySystemTripped
                except Pyro4.errors.CommunicationError:
                    return CommandStatus.CannotCommunicateWithSecuritySystem

            # systemd starts teld with a clean environment
            # load the talon-specific environment just for talon
            talon_env = environment_from_source('/etc/profile.d/talon.sh')
            with open(os.devnull, 'w') as devnull:
                daemon_args = ['/usr/local/telescope/bin/rund', 'telescoped']
                if self._config.virtual:
                    daemon_args.append('-v')

                subprocess.call(daemon_args, env=talon_env, stdout=devnull, stderr=devnull)

            with self._pointing_condition:
                self._pointing_condition.wait(self._config.initialization_timeout)

            if self._pointing_state == TelState.Absent:
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disables and powers off the telescope"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._pointing_state == TelState.Absent:
                return CommandStatus.TelescopeNotInitialized

            # Send a shutdown signal to telescoped, which will
            # stop any motion and gracefully exit
            # The main daemon thread will detect the shm data becoming stale
            # and clean up our internal state in teld
            os.kill(self._talon_pid, signal.SIGINT)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def find_homes(self):
        """Finds the axis home positions"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._pointing_state == TelState.Absent:
                return CommandStatus.TelescopeNotInitialized

            if self._pointing_state != TelState.Stopped:
                return CommandStatus.TelescopeNotStopped

            log.info(self._config.log_name, 'Homing HA axis')
            if not self.__point('homeH', TelState.Homing, TelState.Stopped, self._config.homing_timeout):
                return CommandStatus.Failed

            log.info(self._config.log_name, 'Homing Dec axis')
            if not self.__point('homeD', TelState.Homing, TelState.Stopped, self._config.homing_timeout):
                return CommandStatus.Failed

            if self._telescope_focus_state != FocusState.Absent:
                log.info(self._config.log_name, 'Homing Focus axis')
                if not self.__focus('home', FocusState.Homing, FocusState.Ready, self._config.homing_timeout):
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def find_limits(self):
        """Performs the home and limit calibrations"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._pointing_state != TelState.Stopped:
                return CommandStatus.TelescopeNotStopped

            slew_to_zenith = 'Alt: 1.570796 Az: 0'
            if not self.__point(slew_to_zenith, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            log.info(self._config.log_name, 'Finding HA limits')
            if not self.__point('limitsH', TelState.Limiting, TelState.Stopped, self._config.limit_timeout):
                return CommandStatus.Failed

            if not self.__point(slew_to_zenith, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            with self._talon_shm_lock:
                self._ha_positive_limit = shm_read_double(self._talon_shm, ShmOffsets.RAPosLim) * u.rad
                self._ha_negative_limit = shm_read_double(self._talon_shm, ShmOffsets.RANegLim) * u.rad

            log.info(self._config.log_name, 'Finding Dec limits')
            if not self.__point('limitsD', TelState.Limiting, TelState.Stopped, self._config.limit_timeout):
                return CommandStatus.Failed

            if not self.__point(slew_to_zenith, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            with self._talon_shm_lock:
                self._dec_positive_limit = shm_read_double(self._talon_shm, ShmOffsets.DecPosLim) * u.rad
                self._dec_negative_limit = shm_read_double(self._talon_shm, ShmOffsets.DecNegLim) * u.rad

            if self._telescope_focus_state != FocusState.Absent:
                log.info(self._config.log_name, 'Finding Focus limits')
                if not self.__focus('limits', FocusState.Limiting, FocusState.Ready, self._config.limit_timeout):
                    return CommandStatus.Failed

                # TODO: Return to the nominal focus point (-1950 um)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active telescope movement"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        if self._pointing_state == TelState.Absent:
            return CommandStatus.TelescopeNotInitialized

        # The stop command overrides all other commands
        self._force_stopped = True

        tel_fifo_succeeded = fifo_write('Tel.in', 'Stop')
        focus_fifo_succeeded = fifo_write('Focus.in', 'Stop')

        if not tel_fifo_succeeded:
            log.error(self._config.log_name, 'Failed to write to Tel.in')
            return CommandStatus.Failed

        if not focus_fifo_succeeded:
            log.error(self._config.log_name, 'Failed to write to Focus.in')
            return CommandStatus.Failed

        # Block until any other pointing commands have terminated before cleaning up
        with self._command_lock:
            self._force_stopped = False

        # TODO: Wait for state to update?

        return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_altaz(self, alt_deg, az_deg):
        """Moves the telescope to a target"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._pointing_state != TelState.Stopped:
                return CommandStatus.TelescopeNotStopped

            # Check against telescope limits
            timenow = Time(Time.now(), location=self._observatory)
            coords = SkyCoord(alt=alt_deg, az=az_deg, unit=u.deg, frame='altaz',
                              location=self._observatory, obstime=Time.now()).icrs
            ha = (timenow.sidereal_time('apparent') - coords.ra).wrap_at(12 * u.hourangle)
            dec = coords.dec

            if ha < self._ha_negative_limit or ha > self._ha_positive_limit:
                log.error(self._config.log_name, 'failed to move to alt {} az {}; ha {} outside limit ({}, {})'.format(
                    alt_deg, az_deg, ha, self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec < self._dec_negative_limit or dec > self._dec_positive_limit:
                log.error(self._config.log_name, 'failed to move to alt {} az {}; dec {} outside limit ({}, {})'.format(
                    alt_deg, az_deg, dec, self._dec_negative_limit, self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            command = 'Alt: {} Az: {}'.format(
                (alt_deg * u.deg).to_value(u.rad),
                (az_deg * u.deg).to_value(u.rad))

            if not self.__point(command, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_radec(self, ra_deg, dec_deg):
        """Moves the telescope to a target"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._pointing_state != TelState.Stopped:
                return CommandStatus.TelescopeNotStopped

            # Check against telescope limits
            timenow = Time(Time.now(), location=self._observatory)
            coords = SkyCoord(ra=ra_deg, dec=dec_deg, unit=u.deg, frame='icrs')
            ha = (timenow.sidereal_time('apparent') - coords.ra).wrap_at(12 * u.hourangle)
            dec = coords.dec.to(u.deg)

            if ha < self._ha_negative_limit or ha > self._ha_positive_limit:
                log.error(self._config.log_name, 'failed to move to ra {} dec{}; ha {} outside limit ({}, {})'.format(
                    ra_deg, dec_deg, dec_deg, self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec < self._dec_negative_limit or dec > self._dec_positive_limit:
                log.error(self._config.log_name, 'failed to move to ra {} dec {}; dec {} outside limit ({}, {})'.format(
                    ra_deg, dec_deg, dec_deg, self._dec_negative_limit, self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            command = 'HA: {} Dec: {}'.format(
                ha.to_value(u.rad),
                dec.to_value(u.rad))

            if not self.__point(command, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def track_radec(self, ra_deg, dec_deg):
        """Moves the telescope to a target and starts tracking"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._pointing_state != TelState.Stopped:
                return CommandStatus.TelescopeNotStopped

            # Check against telescope limits
            timenow = Time(Time.now(), location=self._observatory)
            coords = SkyCoord(ra=ra_deg, dec=dec_deg, unit=u.deg, frame='icrs')
            ha = (timenow.sidereal_time('apparent') - coords.ra).wrap_at(12 * u.hourangle)
            ra = coords.ra.to(u.deg)
            dec = coords.dec.to(u.deg)

            if ha < self._ha_negative_limit or ha > self._ha_positive_limit:
                log.error(self._config.log_name, 'failed to move to ra {} dec{}; ha {} outside limit ({}, {})'.format(
                    ra, dec, ha, self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec < self._dec_negative_limit or dec > self._dec_positive_limit:
                log.error(self._config.log_name, 'failed to move to ra {} dec {}; dec {} outside limit ({}, {})'.format(
                    ra, dec, dec, self._dec_negative_limit, self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            # Slewing is much faster than tracking
            command = 'HA: {} Dec: {}'.format(
                ha.to_value(u.rad),
                dec.to_value(u.rad))

            if not self.__point(command, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                return CommandStatus.Failed

            # Do the final adjustment and start tracking
            command = 'RA: {} Dec: {} Epoch: 2000'.format(
                ra.to_value(u.rad),
                dec.to_value(u.rad))

            if not self.__point(command, TelState.Hunting, TelState.Tracking, self._config.slew_timeout):
                return CommandStatus.Failed

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def offset_radec(self, ra_delta_deg, dec_delta_deg):
        """Offsets the telescope relative to the current position"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._pointing_state == TelState.Tracking:
                # When tracking we must use the xdelta offset to directly
                # offset at the motor controller
                offset_ra = self._offset_ra + ra_delta_deg * u.deg
                offset_dec = self._offset_dec + dec_delta_deg * u.deg

                # xdelta expects angles in degrees
                fifo_command = 'xdelta({},{})'.format(
                    offset_ra.to_value(u.deg),
                    offset_dec.to_value(u.deg))

                if not fifo_write('Tel.in', fifo_command):
                    log.error(self._config.log_name, 'Failed to write to Tel.in')
                    return CommandStatus.Failed

                self._offset_ra = offset_ra
                self._offset_dec = offset_dec
            elif self._pointing_state == TelState.Stopped:
                # Otherwise just slew to the updated position
                with self._talon_shm_lock:
                    command = 'HA: {} Dec: {}'.format(
                        self._current_ha_apparent.to_value(u.rad),
                        self._current_dec_apparent.to_value(u.rad))

                if not self.__point(command, TelState.Slewing, TelState.Stopped, self._config.slew_timeout):
                    return CommandStatus.Failed

                self._offset_ra += ra_delta_deg * u.deg
                self._offset_dec += dec_delta_deg * u.deg
            else:
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def telescope_focus(self, focus_um):
        """Moves the main telescope focus to a specified position"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if not self._axes_homed:
                return CommandStatus.TelescopeNotHomed

            if self._telescope_focus_state == FocusState.Absent:
                return CommandStatus.Failed

            # TODO: merge this into the __focus command
            with self._telescope_focus_condition:
                focus_offset = focus_um - self._telescope_focus_um
                if math.fabs(focus_offset) < self._config.focus_tolerance:
                    return CommandStatus.Succeeded

                if not fifo_write('Focus.in', str(focus_offset)):
                    log.error(self._config.log_name, 'Failed to write to Focus.in')
                    return CommandStatus.Failed

                while True:
                    self._telescope_focus_condition.wait(self._config.focus_timeout)
                    stopped = self._force_stopped or self._pointing_state == TelState.Absent
                    moved = self._telescope_focus_um != self._last_telescope_focus_um
                    complete = math.fabs(focus_um - self._telescope_focus_um) < self._config.focus_tolerance

                    # Keep waiting until we reach the requested focus, timeout (haven't moved),
                    # or have been explicitly stopped
                    if complete or stopped or not moved:
                        break

                return CommandStatus.Succeeded if complete else CommandStatus.Failed

    def __move_covers(self, to_open=True):
        """Open or close the mirror covers"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._pointing_state == TelState.Absent:
                return CommandStatus.TelescopeNotInitialized

            if self._cover_state == CoverState.Absent:
                return CommandStatus.Failed

            if to_open:
                log.info(self._config.log_name, 'Opening covers')
            else:
                log.info(self._config.log_name, 'Closing covers')

            fifo_command = 'coveropen' if to_open else 'coverclose'
            active_state = CoverState.Opening if to_open else CoverState.Closing
            final_state = CoverState.Open if to_open else CoverState.Closed
            timeout = self._config.cover_timeout

            with self._cover_condition:
                if not fifo_write('Cover.in', fifo_command):
                    log.error(self._config.log_name, 'Failed to write to Cover.in')
                    return CommandStatus.Failed

                while True:
                    self._cover_condition.wait(timeout)
                    stopped = self._pointing_state == TelState.Absent

                    # Ignore the initial state to <active_state>, which we may or
                    # may not receive depending on the timing of the telstat loop
                    if self._cover_state == active_state and not stopped:
                        continue
                    break

                if self._cover_state != final_state or stopped:
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def open_covers(self):
        """Open the mirror covers"""
        return self.__move_covers(True)

    @Pyro4.expose
    def close_covers(self):
        """Close the mirror covers"""
        return self.__move_covers(False)

    def __move_roof(self, to_open=True):
        """Open or close the roof"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._pointing_state == TelState.Absent:
                return CommandStatus.TelescopeNotInitialized

            if self._roof_state == RoofState.Absent:
                return CommandStatus.Failed

            if to_open:
                log.info(self._config.log_name, 'Opening roof')
            else:
                log.info(self._config.log_name, 'Closing roof')

            fifo_command = 'open' if to_open else 'close'
            active_state = RoofState.Opening if to_open else RoofState.Closing
            final_state = RoofState.Open if to_open else RoofState.Closed
            timeout = self._config.roof_open_timeout if to_open else self._config.roof_close_timeout

            with self._roof_condition:
                if not fifo_write('Dome.in', fifo_command):
                    log.error(self._config.log_name, 'Failed to write to Dome.in')
                    return CommandStatus.Failed

                while True:
                    self._roof_condition.wait(timeout)
                    stopped = self._pointing_state == TelState.Absent

                    # Ignore the initial state to <active_state>, which we may or
                    # may not receive depending on the timing of the telstat loop
                    if self._roof_state == active_state and not stopped:
                        continue
                    break

                if self._roof_state != final_state or stopped:
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def open_roof(self):
        """Open the roof"""
        return self.__move_roof(True)

    @Pyro4.expose
    def close_roof(self):
        """Close the roof"""
        return self.__move_roof(False)

    @Pyro4.expose
    def ping(self):
        """Returns immediately with a success status"""
        return CommandStatus.Succeeded


def environment_from_source(source_path):
    """Returns a dictionary of environment variables obtained after sourcing a file
       into a clean environment"""
    try:
        command = ['bash', '-c', 'source ' + source_path + ' && env']
        output = subprocess.check_output(command, universal_newlines=True, timeout=5)
        ret = dict()
        for line in output.split('\n'):
            (key, _, value) = line.partition('=')
            ret[key] = value
        return ret
    except Exception:
        return dict()


def fifo_write(fifo_name, fifo_data):
    """Writes a string into the named fifo"""
    try:
        # Don't create a new file if the fifo doesn't exist
        fd = os.open(FIFO_PATH+fifo_name, os.O_WRONLY)
    except OSError:
        return False

    with os.fdopen(fd, 'w') as fifo:
        print('Writing to ' + fifo_name + ': ' + fifo_data)
        fifo.write(fifo_data + '\n')
        return True


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Telescope Server')
    parser.add_argument('config', help='Path to configuration json file')
    args = parser.parse_args()
    c = Config(args.config)
    c.daemon.launch(TelescopeDaemon(c))
