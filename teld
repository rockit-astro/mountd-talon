#!/usr/bin/env python3
#
# This file is part of teld.
#
# teld is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# teld is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with teld.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=no-self-use
# pylint: disable=too-many-statements
# pylint: disable=bare-except
# pylint: disable=too-many-lines
# pylint: disable=broad-except

import glob
import math
import os
import struct
import subprocess
import sysv_ipc
import threading
import time
import ephem
import Pyro4

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'

PYRO_COMM_TIMEOUT = 5

TELD_HOST = '192.168.0.101'
TELD_PORT = 9003
TELD_NAME = 'telescope_daemon'

POWERD_HOST = '192.168.0.102'
POWERD_PORT = 9009
POWERD_NAME = 'onemetre_power_daemon'

ROOMALERTD_HOST = '192.168.0.102'
ROOMALERTD_PORT = 9008
ROOMALERTD_NAME = 'onemetre_roomalert_daemon'

POWERD_URI = 'PYRO:' + POWERD_NAME + '@' + POWERD_HOST + ':' + str(POWERD_PORT)
ROOMALERTD_URI = 'PYRO:' + ROOMALERTD_NAME + '@' + ROOMALERTD_HOST + ':' + str(ROOMALERTD_PORT)

FIFO_PATH = '/usr/local/telescope/comm/'
FIFO_NAMES = ['Tel.in', 'Cover.in', 'Focus.in']

# Shared memory offsets
TALON_SHM_KEY = 0x4e56361a
SHM_MJD_OFFSET = 0

SHM_RA_OFFSET = 88
SHM_DEC_OFFSET = 96

# Site properties
SHM_LATITUDE_OFFSET = 8
SHM_LONGITUDE_OFFSET = 16
SHM_ELEVATION_OFFSET = 48

# Telescope properties
SHM_TEL_STATE_OFFSET = 920
SHM_COVER_STATE_OFFSET = 976
SHM_RA_AXIS = 248
SHM_DEC_AXIS = SHM_RA_AXIS + 120
SHM_FOCUS_AXIS = SHM_RA_AXIS + 360
SHM_AXIS_FLAGS = 1
SHM_AXIS_CPOS = 96
SHM_AXIS_STEP = 4
SHM_AXIS_DF = 80
SHM_AXIS_POSLIM = 56
SHM_AXIS_NEGLIM = 64

# How close we consider to be close enough for focus
TELESCOPE_FOCUS_TOLERANCE = 0.005

# Delay between telstat queries (in seconds)
TELSTAT_QUERY_DELAY = 1

# Covers should update immediately, so delay mainly covers fifo / telstat delays
COVER_TIMEOUT = 2.5

# Homing and limit timeouts are per-axis
HOMING_TIMEOUT = 120
LIMIT_TIMEOUT = 120

SLEW_TIMEOUT = 120
FOCUS_TIMEOUT = 60

# Time for talon and the telescope hardware to boot to a usable state
INITIALIZATION_TIMEOUT = 60

SLEW_TO_ZENITH = 'Alt: 1.570796 Az: 0'

# This should be kept in sync with the dictionary in tel
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

    CannotCommunicateWithPowerDaemon = 5
    CannotCommunicateWithRoomAlertDaemon = 6
    SecuritySystemTripped = 7

    # Command-specific codes
    TelescopeNotInitialized = 10
    TelescopeNotReady = 11
    TelescopeNotTracking = 12
    TelescopeNotGuiding = 13
    TelescopeNotUninitialized = 14
    TelescopeIsTracking = 15
    TelescopeIsGuiding = 16

    OutsideHALimits = 20
    OutsideDecLimits = 21

class TelescopeStatus:
    """Status of the telescope hardware"""
    Disabled, NotHomed, Ready, Tracking, Guiding = range(5)
    Names = ['DISABLED', 'ONLINE BUT NOT HOMED', 'IDLE', 'TRACKING', 'GUIDING']

class TelState:
    """Talon TelState enum"""
    Stopped, Hunting, Tracking, Slewing, Homing, Limiting = range(6)
    Names = ['TS_STOPPED', 'TS_HUNTING', 'TS_TRACKING', 'TS_SLEWING', 'TS_HOMING', 'TS_LIMITING']

class FocusState:
    """Focus status built from talon motor flags"""
    NotHomed, Homing, Limiting, Ready = range(4)
    Names = ['FOC_NOT_HOMED', 'FOC_HOMING', 'FOC_LIMITING', 'FOC_READY']

class CoverState:
    """Talon CoverState enum"""
    Absent, Idle, Opening, Closing, Open, Closed = range(6)
    Names = ['CV_ABSENT', 'CV_IDLE', 'CV_OPENING', 'CV_CLOSING', 'CV_OPEN', 'CV_CLOSED']

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class TelescopeDaemon:
    """Daemon interface for talon subystems"""
    def __init__(self):
        # Motor offsets for jogging and autoguiding
        # Measured in radians
        self._offset_ra = 0
        self._offset_dec = 0

        # Only one command may be active at a time (except for stop)
        self._command_lock = threading.Lock()
        self._pointing_condition = threading.Condition()
        self._cover_condition = threading.Condition()
        self._telescope_focus_condition = threading.Condition()
        self._status_condition = threading.Condition()
        self._force_stopped = False

        self._last_status = TelescopeStatus.Disabled
        self._status = TelescopeStatus.Disabled

        # Status data from shared memory
        self._talon_shm = None
        self._talon_shm_lock = threading.Lock()

        self._observatory = None
        self._current_ra = 0
        self._current_dec = 0
        self._last_pointing_state = TelState.Stopped
        self._pointing_state = TelState.Stopped

        self._last_cover_state = CoverState.Absent
        self._cover_state = CoverState.Absent

        self._last_telescope_focus_state = FocusState.NotHomed
        self._telescope_focus_state = FocusState.NotHomed
        self._telescope_focus_um = 0
        self._last_telescope_focus_um = 0

        self._ha_positive_limit = 0
        self._ha_negative_limit = 0
        self._dec_positive_limit = 0
        self._dec_negative_limit = 0

        self._last_talon_mjd = 0
        self._talon_mjd = 0

        tel_status_thread = threading.Thread(target=self.__poll_tel_status)
        tel_status_thread.daemon = True
        tel_status_thread.start()

    def __update_state_from_talon_shm(self):
        """Update local copies of state variables from talon shared memory segment"""
        try:
            talon_alive = True
            if self._talon_shm is None:
                self._talon_shm = sysv_ipc.SharedMemory(TALON_SHM_KEY)

            with self._talon_shm_lock:
                self._last_talon_mjd = self._talon_mjd
                self._talon_mjd = shm_read_double(self._talon_shm, SHM_MJD_OFFSET)

                # The first stage of talon boot up zeros the shared memory.
                # Wait for it to be updated with sensible data
                if self._talon_mjd > 0:
                    self._last_pointing_state = self._pointing_state
                    self._pointing_state = shm_read_int(self._talon_shm,
                                                        SHM_TEL_STATE_OFFSET)

                    self._last_cover_state = self._cover_state
                    self._cover_state = shm_read_int(self._talon_shm,
                                                     SHM_COVER_STATE_OFFSET)

                    self._current_ra = shm_read_double(self._talon_shm, SHM_RA_OFFSET)
                    self._current_dec = shm_read_double(self._talon_shm, SHM_DEC_OFFSET)

                    focus_flags = shm_read_ushort(self._talon_shm, SHM_FOCUS_AXIS + SHM_AXIS_FLAGS)
                    focus_step = shm_read_int(self._talon_shm, SHM_FOCUS_AXIS + SHM_AXIS_STEP)
                    focus_pos = shm_read_double(self._talon_shm, SHM_FOCUS_AXIS + SHM_AXIS_CPOS)
                    focus_df = shm_read_double(self._talon_shm, SHM_FOCUS_AXIS +SHM_AXIS_DF)

                    self._last_telescope_focus_state = self._telescope_focus_state
                    self._telescope_focus_state = FocusState.NotHomed
                    if focus_flags & 0x80 != 0:
                        self._telescope_focus_state = FocusState.Homing
                    elif focus_flags & 0x100 != 0:
                        self._telescope_focus_state = FocusState.Limiting
                    elif focus_flags & 0x200 != 0:
                        self._telescope_focus_state = FocusState.Ready

                    self._last_telescope_focus_um = self._telescope_focus_um
                    self._telescope_focus_um = focus_step * focus_pos / \
                        (2 * math.pi * focus_df)

        except sysv_ipc.ExistentialError:
            # Talon has not been initialized since last boot
            talon_alive = False
        except Exception as e:
            # Some other unexpected error occurred - log it
            print('Failed parsing shared memory: ' + str(e))
            talon_alive = False

        # Talon stops updating the shared memory if the hardware crashes
        # We use this as a proxy for checking that the daemons are operating correctly
        talon_alive = talon_alive and self._talon_mjd > 0 and \
            self._last_talon_mjd != self._talon_mjd

        if not talon_alive and self._status != TelescopeStatus.Disabled:
            # Talon has just died on us!
            print('Talon is offline')

            # Wake up any active commands so that they can fail
            self._pointing_condition.notify()
            self._cover_condition.notify()

            # Kill telescoped and csimcd
            print('Killing rund-spawned daemons')
            subprocess.call(['/usr/bin/killall', 'rund'])

            # Clear interprocess-communication channels
            for f in glob.glob('/usr/local/telescope/comm/*'):
                print('Removing ' + f)
                os.unlink(f)

            self._status = TelescopeStatus.Disabled
        elif talon_alive and self._status == TelescopeStatus.Disabled:
            # Either we or talon has been restarted... find current status
            print('Talon is online')

            with self._talon_shm_lock:
                ra_flags = shm_read_ushort(self._talon_shm, SHM_RA_AXIS + SHM_AXIS_FLAGS)
                dec_flags = shm_read_ushort(self._talon_shm, SHM_DEC_AXIS + SHM_AXIS_FLAGS)
                focus_flags = shm_read_ushort(self._talon_shm, SHM_FOCUS_AXIS + SHM_AXIS_FLAGS)

                # Update observatory state
                obs = ephem.Observer()
                # pylint: disable=assigning-non-slot
                obs.lon = shm_read_double(self._talon_shm, SHM_LONGITUDE_OFFSET)
                obs.lat = shm_read_double(self._talon_shm, SHM_LATITUDE_OFFSET)
                obs.elevation = shm_read_double(self._talon_shm, SHM_ELEVATION_OFFSET) * 6.37816e6
                obs.pressure = 0
                obs.epoch = ephem.J2000
                # pylint: enable=assigning-non-slot
                self._observatory = obs

                # Update limits
                self._ha_positive_limit = shm_read_double(self._talon_shm,
                                                          SHM_RA_AXIS + SHM_AXIS_POSLIM)
                self._ha_negative_limit = shm_read_double(self._talon_shm,
                                                          SHM_RA_AXIS + SHM_AXIS_NEGLIM)
                self._dec_positive_limit = shm_read_double(self._talon_shm,
                                                           SHM_DEC_AXIS + SHM_AXIS_POSLIM)
                self._dec_negative_limit = shm_read_double(self._talon_shm,
                                                           SHM_DEC_AXIS + SHM_AXIS_NEGLIM)

            # Check whether the axes are already homed
            # TODO: Add `and focus_flags & 0x200 != 0` after fixing focus encoder
            if ra_flags & 0x200 != 0 and dec_flags & 0x200 != 0:
                self._status = TelescopeStatus.Ready
            else:
                self._status = TelescopeStatus.NotHomed

    def __poll_tel_status(self):
        """Background thread that polls shared memory for the current telescope status"""
        while True:
            # Acquire all condition locks to avoid races with commands
            with self._cover_condition:
                with self._pointing_condition:
                    with self._telescope_focus_condition:
                        with self._status_condition:
                            self.__update_state_from_talon_shm()

                            if self._last_pointing_state != self._pointing_state:
                                print(TelState.Names[self._last_pointing_state] + ' -> ' + \
                                      TelState.Names[self._pointing_state])
                                self._pointing_condition.notify()

                            if self._last_cover_state != self._cover_state:
                                print(CoverState.Names[self._last_cover_state] + ' -> ' + \
                                      CoverState.Names[self._cover_state])
                                self._cover_condition.notify()

                            if self._last_telescope_focus_um != self._telescope_focus_um:
                                print('tel focus: {:2f} -> {:2f}'.format(
                                    self._last_telescope_focus_um, self._telescope_focus_um))
                                self._telescope_focus_condition.notify()

                            if self._telescope_focus_state != self._last_telescope_focus_state:
                                print(FocusState.Names[self._last_telescope_focus_state] + \
                                    ' -> ' + FocusState.Names[self._telescope_focus_state])
                                self._telescope_focus_condition.notify()

                            if self._last_status != self._status:
                                print(TelescopeStatus.Names[self._last_status] + ' -> ' + \
                                    TelescopeStatus.Names[self._status])
                                self._status_condition.notify()

                            self._last_status = self._status

            time.sleep(TELSTAT_QUERY_DELAY)

    def __local_sidereal_time(self):
        """Returns the local sidereal time in radians"""
        self._observatory.date = ephem.now()
        return float(self._observatory.sidereal_time())

    def __alt_az_from_ra_dec(self, ra_radians, dec_radians):
        """Returns the Alt and Az in radians for a given RA and Dec"""
        coords = ephem.FixedBody()
        # pylint: disable=protected-access
        coords._ra = ra_radians
        coords._dec = dec_radians
        coords._epoch = ephem.J2000
        # pylint: enable=protected-access

        self._observatory.date = ephem.now()
        coords.compute(self._observatory)
        return float(coords.alt), float(coords.az)

    def __ra_dec_from_alt_az(self, alt_radians, az_radians):
        """Returns the HA and Dec in radians for a given Alt and Az"""
        self._observatory.date = ephem.now()
        ra, dec = self._observatory.radec_of(az_radians, alt_radians)
        return float(ra), float(dec)

    def __ha_from_ra(self, ra_radians):
        """Returns the HA and Dec in radians for a given RA and Dec"""
        ha = self.__local_sidereal_time() - ra_radians
        # Deal with the 24 <-> 0 wraparound
        while ha > math.pi:
            ha -= 2 * math.pi

        while ha < -math.pi:
            ha += 2 * math.pi

        return ha

    def __reset_pointing_offset(self):
        """Resets the pointing xdelta"""
        if not fifo_write('Tel.in', 'xdelta(0,0)'):
            print('Failed to write to Tel.in')
            return False

        self._offset_ra = 0
        self._offset_dec = 0
        return True

    def __point(self, fifo_command, active_state, final_state, timeout):
        """Issues a pointing command and blocks until the final state is reached (or timeout)"""
        with self._pointing_condition:
            if not fifo_write('Tel.in', fifo_command):
                print('Failed to write to Tel.in')
                return False

            stopped = False
            while True:
                self._pointing_condition.wait(timeout)
                stopped = self._force_stopped or self._status == TelescopeStatus.Disabled

                # Ignore the initial state change to <active_state>, which we may
                # or may not recieve depending on the timing of the telstat loop
                if self._pointing_state == active_state and not stopped:
                    continue
                break

            if self._pointing_state != final_state or stopped:
                return False

        return True

    def __focus(self, fifo_command, active_state, final_state, timeout):
        """Issues a focus command and blocks until the final state is reached (or timeout)"""
        with self._telescope_focus_condition:
            if not fifo_write('Focus.in', fifo_command):
                print('Failed to write to Focus.in')
                return False

            stopped = False
            complete = False
            while True:
                self._telescope_focus_condition.wait(timeout)
                stopped = self._force_stopped or self._status == TelescopeStatus.Disabled

                # Ignore the initial state change to <active_state>, which we may
                # or may not recieve depending on the timing of the telstat loop
                if self._telescope_focus_state == active_state and not stopped:
                    continue
                break

            if self._telescope_focus_state != final_state or stopped:
                return False

        return True

    def __slew_to_radec(self, ra_radians, dec_radians):
        """Quickly slew to a specified RA and Dec"""
        # Uses the "HA: Dec:" command to slew
        ha_radians = self.__ha_from_ra(ra_radians)
        command = 'HA: {} Dec: {}'.format(ha_radians, dec_radians)
        return self.__point(command, TelState.Slewing, TelState.Stopped, SLEW_TIMEOUT)

    def __move_covers(self, fifo_command, active_state, final_state, timeout):
        """Issues a cover command and blocks until the final state is reached (or timeout)"""
        with self._cover_condition:
            if not fifo_write('Cover.in', fifo_command):
                print('Failed to write to Cover.in')
                return False

            stopped = False
            while True:
                self._cover_condition.wait(timeout)
                stopped = self._status == TelescopeStatus.Disabled

                # Ignore the initial state to <active_state>, which we may or
                # may not recieve depending on the timing of the telstat loop
                if self._cover_state == active_state and not stopped:
                    continue
                break

            if self._cover_state != final_state or stopped:
                return False
        return True

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current telescope state"""
        data = {
            'state': self._status,
            'state_label': TelescopeStatus.Names[self._status],
            'software_version': SOFTWARE_VERSION
        }

        if self._observatory is not None:
            data.update({
                'site_latitude': float(self._observatory.lat),
                'site_longitude': float(self._observatory.lon),
                'site_elevation': float(self._observatory.elevation),
            })

        if self._status != TelescopeStatus.Disabled:
            alt, az = self.__alt_az_from_ra_dec(self._current_ra, self._current_dec)
            data.update({
                'pointing_state': TelState.Names[self._pointing_state],
                'cover_state': CoverState.Names[self._cover_state],
                'telescope_focus_state': FocusState.Names[self._telescope_focus_state],

                'ra': self._current_ra,
                'dec': self._current_dec,
                'offset_ra': self._offset_ra,
                'offset_dec': self._offset_dec,

                'alt': alt,
                'az': az,
                'lst': self.__local_sidereal_time(),

                'telescope_focus_um': self._telescope_focus_um,
            })

        return data

    @Pyro4.expose
    def initialize(self):
        """Turns on the power and starts the lower level hardware daemons"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotUninitialized

            # Check hard limits (security system)
            try:
                with Pyro4.Proxy(ROOMALERTD_URI) as roomalert:
                    status = roomalert.last_measurement()
                    if 'security_system_safe' not in status or not status['security_system_safe']:
                        return CommandStatus.SecuritySystemTripped
            except Pyro4.errors.CommunicationError:
                return CommandStatus.CannotCommunicateWithRoomAlertDaemon

            # Turn on CSIMC controller card power
            try:
                with Pyro4.Proxy(POWERD_URI) as power:
                    if not power.switch('telescope_12v', True):
                        return CommandStatus.CannotCommunicateWithPowerDaemon
            except Pyro4.errors.CommunicationError:
                return CommandStatus.CannotCommunicateWithPowerDaemon

            # systemd starts teld with a clean environment
            # load the talon-specific environment just for talon
            talon_env = environment_from_source('/etc/profile.d/talon.sh')
            with open(os.devnull, 'w') as devnull:
                subprocess.call(['/usr/local/telescope/bin/rund', 'telescoped'], env=talon_env,
                                stdout=devnull, stderr=devnull)

            with self._status_condition:
                self._status_condition.wait(INITIALIZATION_TIMEOUT)

            if self._status == TelescopeStatus.Disabled:
                # Clean up after failed initialization
                try:
                    with Pyro4.Proxy(POWERD_URI) as power:
                        if not power.switch('telescope_12v', False):
                            return CommandStatus.CannotCommunicateWithPowerDaemon
                except Pyro4.errors.CommunicationError:
                    return CommandStatus.CannotCommunicateWithPowerDaemon

                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disables and powers off the telescope"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            # Turn off CSIMC controller card power
            # The main daemon thread will detect the cards going away
            # and clean up as required.
            try:
                with Pyro4.Proxy(POWERD_URI) as power:
                    if not power.switch('telescope_12v', False):
                        return CommandStatus.CannotCommunicateWithPowerDaemon
            except Pyro4.errors.CommunicationError:
                return CommandStatus.CannotCommunicateWithPowerDaemon

            return CommandStatus.Succeeded

    @Pyro4.expose
    def find_homes(self):
        """Finds the axis home positions"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            if self._status > TelescopeStatus.Ready:
                return CommandStatus.TelescopeIsTracking

            print('Homing HA axis...')
            if not self.__point('homeH', TelState.Homing, TelState.Stopped, HOMING_TIMEOUT):
                return CommandStatus.Failed

            print('Homing Dec axis...')
            if not self.__point('homeD', TelState.Homing, TelState.Stopped, HOMING_TIMEOUT):
                return CommandStatus.Failed

            # TODO: disabled while focus encoder is broken
            # print('Homing Focus axis...')
            # if not self.__focus('home', FocusState.Homing, FocusState.Ready, HOMING_TIMEOUT):
            #     return CommandStatus.Failed

            self._status = TelescopeStatus.Ready
            return CommandStatus.Succeeded

    @Pyro4.expose
    def find_limits(self):
        """Performs the home and limit calibrations"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._status > TelescopeStatus.Ready:
                return CommandStatus.TelescopeIsTracking

            if not self.__point(SLEW_TO_ZENITH, TelState.Slewing, TelState.Stopped,
                                SLEW_TIMEOUT):
                return CommandStatus.Failed

            print('Finding HA limits...')
            if not self.__point('limitsH', TelState.Limiting, TelState.Stopped, LIMIT_TIMEOUT):
                return CommandStatus.Failed

            if not self.__point(SLEW_TO_ZENITH, TelState.Slewing, TelState.Stopped, SLEW_TIMEOUT):
                return CommandStatus.Failed

            with self._talon_shm_lock:
                self._ha_positive_limit = shm_read_double(self._talon_shm,
                                                          SHM_RA_AXIS + SHM_AXIS_POSLIM)
                self._ha_negative_limit = shm_read_double(self._talon_shm,
                                                          SHM_RA_AXIS + SHM_AXIS_NEGLIM)

            print('Finding Dec limits...')
            if not self.__point('limitsD', TelState.Limiting, TelState.Stopped, LIMIT_TIMEOUT):
                return CommandStatus.Failed

            if not self.__point(SLEW_TO_ZENITH, TelState.Slewing, TelState.Stopped, SLEW_TIMEOUT):
                return CommandStatus.Failed

            with self._talon_shm_lock:
                self._dec_positive_limit = shm_read_double(self._talon_shm,
                                                           SHM_DEC_AXIS + SHM_AXIS_POSLIM)
                self._dec_negative_limit = shm_read_double(self._talon_shm,
                                                           SHM_DEC_AXIS + SHM_AXIS_NEGLIM)

            # TODO: disabled while focus encoder is broken
            # print('Finding Focus limits...')
            # if not self.__focus('limits', FocusState.Limiting, FocusState.Ready, LIMIT_TIMEOUT):
            #     return CommandStatus.Failed

            # TODO: Return to the nominal focus point (-1950 um)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active telescope movement"""
        if self._status == TelescopeStatus.Disabled:
            return CommandStatus.TelescopeNotInitialized

        # The stop command overrides all other commands
        self._force_stopped = True

        tel_fifo_succeeded = fifo_write('Tel.in', 'Stop')
        focus_fifo_succeeded = fifo_write('Focus.in', 'Stop')
        if not tel_fifo_succeeded:
            print('Failed to write to Tel.in')
            return CommandStatus.Failed

        if not focus_fifo_succeeded:
            print('Failed to write to Focus.in')
            return CommandStatus.Failed

        if self._status > TelescopeStatus.Ready:
            self._status = TelescopeStatus.Ready

        with self._pointing_condition:
            self._pointing_condition.notify_all()

        with self._telescope_focus_condition:
            self._telescope_focus_condition.notify_all()

        # Block until any other pointing commands have terminated before cleaning up
        with self._command_lock:
            self._force_stopped = False

        return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_altaz(self, alt_radians, az_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._status > TelescopeStatus.Ready:
                return CommandStatus.TelescopeIsTracking

            # Check against telescope limits
            ra, dec = self.__ra_dec_from_alt_az(alt_radians, az_radians)
            ha = self.__ha_from_ra(ra)

            if ha < self._ha_negative_limit or ha > self._ha_positive_limit:
                print('failed to move to alt {} az {}; ha {} outside limit ({}, {})'.format(
                    alt_radians, az_radians, ha, self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec < self._dec_negative_limit or dec > self._dec_positive_limit:
                print('failed to move to alt {} az {}; dec {} outside limit ({}, {})'.format(
                    alt_radians, az_radians, dec, self._dec_negative_limit,
                    self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            command = 'Alt: {} Az: {}'.format(alt_radians, az_radians)
            if not self.__point(command, TelState.Slewing, TelState.Stopped, SLEW_TIMEOUT):
                return CommandStatus.Failed

            if self._status > TelescopeStatus.Ready:
                self._status = TelescopeStatus.Ready

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def slew_radec(self, ra_radians, dec_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._status > TelescopeStatus.Ready:
                return CommandStatus.TelescopeIsTracking

            # Check against telescope limits
            ha_radians = self.__ha_from_ra(ra_radians)
            if ha_radians < self._ha_negative_limit or dec_radians > self._ha_positive_limit:
                print('failed to move to ra {} dec{}; ha {} outside limit ({}, {})'.format(
                    ra_radians, dec_radians, dec_radians,
                    self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec_radians < self._dec_negative_limit or dec_radians > self._dec_positive_limit:
                print('failed to move to ra {} dec {}; dec {} outside limit ({}, {})'.format(
                    ra_radians, dec_radians, dec_radians, self._dec_negative_limit,
                    self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            if not self.__slew_to_radec(ra_radians, dec_radians):
                return CommandStatus.Failed

            if self._status > TelescopeStatus.Ready:
                self._status = TelescopeStatus.Ready

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def track_radec(self, ra_radians, dec_radians):
        """Moves the telescope to a target and starts tracking"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._status == TelescopeStatus.Guiding:
                return CommandStatus.TelescopeIsGuiding

            # Check against telescope limits
            ha_radians = self.__ha_from_ra(ra_radians)
            if ha_radians < self._ha_negative_limit or ha_radians > self._ha_positive_limit:
                print('failed to move to ra {} dec{}; ha {} outside limit ({}, {})'.format(
                    ra_radians, dec_radians, ha_radians,
                    self._ha_negative_limit, self._ha_positive_limit))
                return CommandStatus.OutsideHALimits

            if dec_radians < self._dec_negative_limit or dec_radians > self._dec_positive_limit:
                print('failed to move to ra {} dec {}; dec {} outside limit ({}, {})'.format(
                    ra_radians, dec_radians, dec_radians, self._dec_negative_limit,
                    self._dec_positive_limit))
                return CommandStatus.OutsideDecLimits

            # Slewing is much faster than tracking
            if not self.__slew_to_radec(ra_radians, dec_radians):
                return CommandStatus.Failed

            # Do the final adjustment and start tracking
            command = 'RA: {} Dec: {} Epoch: 2000'.format(ra_radians, dec_radians)
            if not self.__point(command, TelState.Hunting, TelState.Tracking, SLEW_TIMEOUT):
                return CommandStatus.Failed

            if not self.__reset_pointing_offset():
                return CommandStatus.Failed

            self._status = TelescopeStatus.Tracking
            return CommandStatus.Succeeded

    @Pyro4.expose
    def offset_radec(self, ra_delta_radians, dec_delta_radians):
        """Offsets the telescope relative to the current position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            if self._status == TelescopeStatus.Guiding:
                return CommandStatus.TelescopeIsGuiding

            if self._status == TelescopeStatus.Tracking:
                # When tracking we must use the xdelta offset to directly
                # offset at the motor controller
                offset_ra = self._offset_ra + ra_delta_radians
                offset_dec = self._offset_dec + dec_delta_radians

                # xdelta expects angles in degrees
                fifo_command = 'xdelta({},{})'.format(
                    offset_ra * 180 / math.pi,
                    offset_dec * 180 / math.pi)

                if not fifo_write('Tel.in', fifo_command):
                    print('Failed to write to Tel.in')
                    return CommandStatus.Failed

                self._offset_ra = offset_ra
                self._offset_dec = offset_dec
            else:
                # Otherwise just slew to the updated position
                with self._talon_shm_lock:
                    ra_radians = self._current_ra + ra_delta_radians
                    dec_radians = self._current_dec + dec_delta_radians

                if not self.__slew_to_radec(ra_radians, dec_radians):
                    return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_guiding(self):
        """Enable the autoguider"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Tracking:
                return CommandStatus.TelescopeNotTracking

            self._status = TelescopeStatus.Guiding
            print('Enabled guiding')

            return CommandStatus.Succeeded

    @Pyro4.expose
    def offset_radec_guiding(self, ra_delta_radians, dec_delta_radians):
        """Offsets the telescope relative to the current position.
           Called by the autoguider code, so bypasses the regular offset
           checks (but only works when guiding is enabled)
        """
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Guiding:
                return CommandStatus.TelescopeNotGuiding

            offset_ra = self._offset_ra + ra_delta_radians
            offset_dec = self._offset_dec + dec_delta_radians

            # xdelta expects angles in degrees
            fifo_command = 'xdelta({},{})'.format(
                offset_ra * 180 / math.pi,
                offset_dec * 180 / math.pi)

            if not fifo_write('Tel.in', fifo_command):
                print('Failed to write to Tel.in')
                return CommandStatus.Failed

            self._offset_ra = offset_ra
            self._offset_dec = offset_dec

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_guiding(self):
        """Stop the autoguider"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Guiding:
                return CommandStatus.TelescopeNotGuiding

            self._status = TelescopeStatus.Tracking

            print('Disabled guiding')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def telescope_focus(self, focus_um):
        """Moves the main telescope focus to a specified position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: disabled while focus encoder is broken
            # if self._status < TelescopeStatus.Ready:
            #     return CommandStatus.TelescopeNotReady

            # TODO: merge this into the __focus command
            with self._telescope_focus_condition:
                focus_offset = focus_um - self._telescope_focus_um
                if math.fabs(focus_offset) < TELESCOPE_FOCUS_TOLERANCE:
                    return CommandStatus.Succeeded

                if not fifo_write('Focus.in', str(focus_offset)):
                    print('Failed to write to Focus.in')
                    return CommandStatus.Failed

                stopped = False
                complete = False
                while True:
                    self._telescope_focus_condition.wait(FOCUS_TIMEOUT)
                    stopped = self._force_stopped or self._status == TelescopeStatus.Disabled
                    moved = self._telescope_focus_um != self._last_telescope_focus_um
                    complete = math.fabs(focus_um - self._telescope_focus_um)\
                        < TELESCOPE_FOCUS_TOLERANCE

                    # Keep waiting until we reach the requested focus, timeout (haven't moved),
                    # or have been explicitly stopped
                    if complete or stopped or not moved:
                        break

                return CommandStatus.Succeeded if complete else CommandStatus.Failed

    @Pyro4.expose
    def open_covers(self):
        """Open the mirror covers"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            print('Opening covers...')
            if not self.__move_covers('coveropen', CoverState.Opening, CoverState.Open,
                                      COVER_TIMEOUT):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def close_covers(self):
        """Close the mirror covers"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == TelescopeStatus.Disabled:
                return CommandStatus.TelescopeNotInitialized

            print('Opening covers...')
            if not self.__move_covers('coverclose', CoverState.Closing, CoverState.Closed,
                                      COVER_TIMEOUT):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def secondary_focus(self, steps):
        """Sets the secondary focus to the specified position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status < TelescopeStatus.Ready:
                return CommandStatus.TelescopeNotReady

            # TODO: Implement secondary focus command
            return CommandStatus.Failed

    @Pyro4.expose
    def ping(self):
        """Returns immediately with a success status"""
        return CommandStatus.Succeeded

def environment_from_source(source_path):
    """Returns a dictionary of environment variables obtained after sourcing a file
       into a clean environment"""
    try:
        command = ['bash', '-c', 'source ' + source_path + ' && env']
        output = subprocess.check_output(command, universal_newlines=True, timeout=5)
        ret = dict()
        for line in output.split('\n'):
            (key, _, value) = line.partition('=')
            ret[key] = value
        return ret
    except:
        return dict()

def fifo_write(fifo_name, fifo_data):
    """Writes a string into the named fifo"""
    try:
        # Don't create a new file if the fifo doesn't exist
        fd = os.open(FIFO_PATH+fifo_name, os.O_WRONLY)
    except OSError:
        return False

    with os.fdopen(fd, 'w') as fifo:
        print('Writing to ' + fifo_name+ ': ' + fifo_data)
        fifo.write(fifo_data+'\n')
        return True

def shm_read_double(shm, offset):
    """read a double from a specified offset in a specified shared memory segment"""
    return struct.unpack_from('d', shm.read(8, offset))[0]

def shm_read_int(shm, offset):
    """read an int from a specified offset in a specified shared memory segment"""
    return struct.unpack_from('i', shm.read(4, offset))[0]

def shm_read_ushort(shm, offset):
    """read a ushort from a specified offset in a specified shared memory segment"""
    return struct.unpack_from('H', shm.read(2, offset))[0]

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=TELD_HOST, port=TELD_PORT)
    telescope = TelescopeDaemon()
    uri = pyro.register(telescope, objectId=TELD_NAME)

    print('Starting telescope daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping telescope daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()
